function _$aX(_$l1, _$aa) {
        var _$fZ, _$eh, _$ja, _$hS, _$dQ, _$_6;
        typeof _$l1 === _$gc[26] ? _$l1 = _$hP(_$l1) : 0,
        _$aa = _$aa || _$$F,
        _$eh = 0,
        _$ja = 0,
        _$hS = _$l1[_$gc[44]],
        _$fZ = new _$e6(_$_x[_$lN[57]](_$hS * _$al[52] / _$al[3])),
        _$hS = _$l1[_$gc[44]] - _$al[43];
        while (_$eh < _$hS)
            _$dQ = _$l1[_$eh++],
            _$fZ[_$ja++] = _$aa[_$dQ >> _$al[43]],
            _$_6 = _$l1[_$eh++],
            _$fZ[_$ja++] = _$aa[((_$dQ & _$al[3]) << _$al[52]) | (_$_6 >> _$al[52])],
            _$dQ = _$l1[_$eh++],
            _$fZ[_$ja++] = _$aa[((_$_6 & _$al[8]) << _$al[43]) | (_$dQ >> _$al[54])],
            _$fZ[_$ja++] = _$aa[_$dQ & _$al[16]];
        _$eh < _$l1[_$gc[44]] ? (_$dQ = _$l1[_$eh],
        _$fZ[_$ja++] = _$aa[_$dQ >> _$al[43]],
        _$_6 = _$l1[++_$eh],
        _$fZ[_$ja++] = _$aa[((_$dQ & _$al[3]) << _$al[52]) | (_$_6 >> _$al[52])],
        _$_6 !== _$jA ? _$fZ[_$ja++] = _$aa[(_$_6 & _$al[8]) << _$al[43]] : 0) : 0;
        return _$h2[4][_$gc[28]](_$fZ, '');
    }
        入口关键词
         || typeof (



关键值是第5次成的
res = '0' + str
            





触发逻辑
 _$bN[_$ls++] = _$eP(_$bN[_$bD])) : _$ez <= 53 ? 
 _$eP(_$bN[_$bD])
 仍需要观察

按照这找
 <= 53 ? 



110位
[
    1,
    58,
    1,
    64,
    30,
    85,
    43,
    43,
    1,
    64,
    30,
    57,
    43,
    1,
    58,
    1,
    64,
    30,
    85,
    43,
    43,
    1,
    64,
    30,
    16,
    43,
    8,
    32,
    1,
    60,
    30,
    62,
    43,
    82,
    23,
    32,
    2,
    13,
    2,
    57,
    0,
    1,
    67,
    30,
    10,
    43,
    17,
    44,
    92,
    52,
    44,
    452,
    23,
    32,
    2,
    11,
    0,
    30,
    0,
    2,
    13,
    3,
    34,
    3,
    57,
    0,
    1,
    67,
    30,
    44,
    43,
    43,
    45,
    54,
    13,
    57,
    0,
    34,
    3,
    34,
    2,
    66,
    32,
    13,
    3,
    61,
    47,
    26,
    1,
    60,
    30,
    43,
    43,
    17,
    38,
    61,
    28,
    38,
    60,
    57,
    0,
    34,
    3,
    34,
    2,
    2,
    32,
    57,
    0,
    46
]

16位
[
    123,
    64,
    139,
    232,
    149,
    181,
    66,
    60,
    83,
    223,
    83,
    108,
    115,
    135,
    229,
    7
]

连接了4个变成了20位
[
    123,
    64,
    139,
    232,
    149,
    181,
    66,
    60,
    83,
    223,
    83,
    108,
    115,
    135,
    229,
    7,
    105,
    33,
    45,
    154
]



完整步骤解析
第一步
搜这个
第二个是的
return [(_
这个函数的作用是 将秒级时间戳变为... 四位数组
1763787953 -> [105, 33, 68, 177]



第二步
132位数组
[
    1,
    0,
    48,
    236,
    165,
    171,
    143,
    117,
    137,
    235,
    41,
    40,
    201,
    62,
    64,
    124,
    64,
    162,
    164,
    71,
    191,
    234,
    92,
    221,
    96,
    240,
    155,
    41,
    14,
    27,
    100,
    58,
    81,
    114,
    250,
    79,
    0,
    248,
    155,
    180,
    241,
    115,
    68,
    232,
    193,
    216,
    252,
    44,
    234,
    150,
    208,
    80,
    131,
    235,
    35,
    41,
    125,
    230,
    105,
    222,
    81,
    144,
    14,
    255,
    208,
    154,
    230,
    158,
    130,
    164,
    145,
    231,
    125,
    183,
    35,
    141,
    66,
    25,
    47,
    171,
    207,
    56,
    0,
    69,
    108,
    253,
    25,
    199,
    233,
    17,
    184,
    46,
    6,
    148,
    138,
    209,
    204,
    195,
    124,
    176,
    11,
    241,
    205,
    212,
    157,
    59,
    18,
    106,
    206,
    100,
    241,
    172,
    66,
    243,
    54,
    135,
    217,
    10,
    105,
    240,
    8,
    8,
    220,
    5,
    73,
    136,
    0,
    155,
    167,
    109,
    76,
    214
]


题外话 
找这个函数
[21]) >>> 0;
处理ua

4号位
51位数组
(可以用来打条件)
[
    1,
    0,
    48,
    42,
    238,
    249,
    247,
    100,
    67,
    76,
    166,
    188,
    118,
    154,
    171,
    39,
    227,
    166,
    158,
    221,
    38,
    217,
    124,
    81,
    184,
    230,
    214,
    240,
    173,
    173,
    171,
    128,
    124,
    209,
    177,
    70,
    25,
    36,
    13,
    217,
    158,
    48,
    177,
    141,
    90,
    100,
    100,
    137,
    147,
    5,
    180
]
5号位
48位数组 会变
[
    42,
    238,
    249,
    247,
    100,
    67,
    76,
    166,
    188,
    118,
    154,
    171,
    39,
    227,
    166,
    158,
    221,
    38,
    217,
    124,
    81,
    184,
    230,
    214,
    240,
    173,
    173,
    171,
    128,
    124,
    209,
    177,
    70,
    25,
    36,
    13,
    217,
    158,
    48,
    177,
    141,
    90,
    100,
    100,
    137,
    147,
    5,
    180
]
_$$j == 28 && _$lL[2] == 1 && typeof _$lL[4] == 'object' && _$lL[4].length = 51

_$$j == 28 && _$lL[7]
跟一下这个地方
<= 29
48位数组是在前面生成的 跟一下前面
[1,0,48]+48位数组+[80]+80位数组拼起来132位数组
4位数组(用一个整数输入生成)+132位数组=136位数组

找哪个是存数据的
          _$kp = _$dI[2]
          这个是的
"""
第一次执行无用
第二次执行
70位数组
(5号位判断一下就行 条件34)
153位数组
秒级时间戳
第三次执行
48位数组
"""
最后一步可参考
输入136位数组
[
    84,
    195,
    126,
    210,
    1,
    0,
    48,
    42,
    238,
    249,
    247,
    100,
    67,
    76,
    166,
    188,
    118,
    154,
    171,
    39,
    227,
    166,
    158,
    221,
    38,
    217,
    124,
    81,
    184,
    230,
    214,
    240,
    173,
    173,
    171,
    128,
    124,
    209,
    177,
    70,
    25,
    36,
    13,
    217,
    158,
    48,
    177,
    141,
    90,
    100,
    100,
    137,
    147,
    5,
    180,
    80,
    255,
    99,
    112,
    129,
    245,
    122,
    229,
    187,
    13,
    228,
    209,
    255,
    12,
    150,
    12,
    21,
    6,
    205,
    246,
    152,
    175,
    132,
    169,
    25,
    128,
    208,
    119,
    76,
    7,
    76,
    80,
    60,
    30,
    152,
    191,
    139,
    24,
    51,
    199,
    215,
    142,
    43,
    57,
    98,
    238,
    181,
    14,
    202,
    251,
    190,
    13,
    222,
    53,
    239,
    237,
    180,
    36,
    42,
    36,
    242,
    48,
    2,
    88,
    102,
    169,
    243,
    153,
    236,
    11,
    207,
    18,
    81,
    136,
    30,
    98,
    82,
    148,
    5,
    198,
    156
]
输出
'YWJ50GlqWc.X5Iw9A0nbBoFFjnIONN4wxz2ZVMObTBcz.FXqIJDSpf99kwb8WhDJKbp9PRWmzmkd36creU.2Xa690IZW2GaYr76Cbt5ljpbq0owWr0SAHr_3Bg73WZIUOP7y3X_Tk7.4BG68J8dzzcAjxHEaq2fbjIiR4qBHl2DEobx12qUDvq'



四位数组生成第一步(生成数字)
应该是在这里生成的 可以试试打这条件断点
VM25:2 当前条件 2 当前栈 (6) [Window, Arguments(4), 1, 空白, Array(132), Array(48)]

逐个跟
排查出结果(加密过程)为 这个数字由132位数组生成
    function _$mj(_$kL) {
        var _$gb, _$_G, _$hQ, _$ec;
        typeof _$kL === _$eN[26] ? _$kL = _$iv(_$kL) : 0,
        _$gb = _$$T[27]._$et || (_$$T[27]._$et = _$fo()),
        _$_G = 0 ^ _$hh[21],
        _$hQ = _$kL[_$eN[44]];
        for (_$ec = 0; _$ec < _$hQ; )
            _$_G = (_$_G >>> _$hh[55]) ^ _$gb[(_$_G ^ _$kL[_$ec++]) & _$hh[20]];
        return (_$_G ^ _$hh[21]) >>> 0;
    }




注意倒推,注意倒推,确保结果100%一定正确



[1,0,48]+48位数组+[80]+80位数组拼起来132位数组
4位数组(用一个整数输入生成)+132位数组=136位数组
_$iV == 46 && _$av[2].length == 16